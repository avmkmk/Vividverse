<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VividVerse Blog</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons like upvote/downvote/comment/share -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <style>
        /* Twitter-inspired color palette: Dark Blue/Black base, Twitter Blue accents, White/Light Grey text */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark Black-Blue (similar to Twitter's dark mode background) */
            color: #e2e8f0; /* Light grey for primary text */
        }
        .header {
            background-color: #10172a; /* Even darker blue-black for header */
            border-bottom: 1px solid #2d3748; /* Darker border */
            box-shadow: 0 1px 5px rgba(0,0,0,0.3); /* More visible shadow on dark background */
            padding: 0.75rem 1.5rem;
        }
        .main-container {
            max-width: 1200px;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            padding: 1.5rem;
        }
        .card {
            background-color: #2d3748; /* Dark grey for card backgrounds (like Reddit post background) */
            border-radius: 0.5rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); /* Prominent shadow for cards */
            padding: 1.5rem;
        }
        .button-primary {
            background-color: #1da1f2; /* Twitter Blue */
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.375rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out;
        }
        .button-primary:hover {
            background-color: #0c85d0; /* Darker Twitter Blue on hover */
        }
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.8); /* Darker overlay for modal */
        }
        .modal-content {
            background-color: #1a202c; /* Modal matches body background */
            border-radius: 0.75rem;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); /* Stronger shadow */
            max-width: 500px;
            width: 90%;
            color: #e2e8f0; /* Light text within modal */
        }
        .input-field {
            background-color: #2d3748; /* Input fields match card background */
            border: 1px solid #4a5568; /* Darker border for inputs */
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            width: 100%;
            color: #e2e8f0; /* Light text in inputs */
        }
        .input-field::placeholder {
            color: #a0aec0; /* Lighter placeholder text */
        }
        .tab-button {
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s ease-in-out;
            color: #a0aec0; /* Light grey for inactive tabs */
        }
        .tab-button.active {
            border-color: #1da1f2; /* Twitter Blue border for active tab */
            color: #e2e8f0; /* White text for active tab */
        }
        .profile-initials {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 9999px;
            background-color: #1da1f2; /* Twitter Blue background */
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s ease-in-out;
        }
        .profile-initials:hover {
            transform: scale(1.05);
        }
        .dropdown-menu {
            position: absolute;
            right: 0;
            top: 100%;
            background-color: #2d3748; /* Dropdown matches card background */
            border-radius: 0.5rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            min-width: 120px;
            padding: 0.5rem 0;
            margin-top: 0.5rem;
            z-index: 1000;
        }
        .dropdown-menu button {
            display: block;
            width: 100%;
            padding: 0.75rem 1rem;
            text-align: left;
            font-size: 0.9rem;
            color: #e2e8f0; /* Light text */
            transition: background-color 0.2s;
        }
        .dropdown-menu button:hover {
            background-color: #4a5568; /* Slightly lighter dark grey on hover */
        }
        .hidden {
            display: none !important;
        }
        /* Reddit-like post specific styles */
        .reddit-post-header {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            color: #a0aec0; /* Lighter grey for meta info */
            margin-bottom: 0.75rem;
        }
        .reddit-post-header .subreddit-icon {
            width: 20px;
            height: 20px;
            border-radius: 9999px;
            background-color: #1da1f2; /* Twitter blue placeholder */
            margin-right: 0.5rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.7rem;
        }
        .reddit-post-footer {
            display: flex;
            align-items: center;
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px solid #4a5568; /* Darker border for footer */
            color: #a0aec0;
            font-size: 0.9rem;
        }
        .reddit-post-footer button {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
        }
        .reddit-post-footer button:hover {
            background-color: #4a5568;
            color: #e2e8f0;
        }
        .reddit-post-footer button i {
            margin-right: 0.5rem;
        }
        .reddit-post-footer .count {
            margin-left: 0.5rem;
            margin-right: 1.5rem;
            font-weight: 600;
        }
        /* Style for the inline reply box */
        .reply-box {
            background-color: #2d3748; /* Match card background */
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 0.75rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .reply-box textarea {
            background-color: #1a202c; /* Darker background for textarea */
            border: 1px solid #4a5568;
            color: #e2e8f0;
            resize: vertical;
        }
        .reply-box .button-group button {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            font-weight: 600;
        }
        .reply-box .button-group .cancel-btn {
            background-color: transparent;
            color: #a0aec0;
            border: 1px solid #4a5568;
        }
        .reply-box .button-group .cancel-btn:hover {
            background-color: #4a5568;
        }
        .reply-box .button-group .comment-btn {
            background-color: #1da1f2; /* Twitter Blue */
            color: white;
        }
        .reply-box .button-group .comment-btn:hover {
            background-color: #0c85d0;
        }
        /* New style for nested comments border */
        .nested-comment-border {
            border-left: 2px solid #4A5568; /* A darker grey for the nested border line */
            padding-left: 0.5rem; /* Add some padding so content doesn't touch the border */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <!-- Header / Navigation Bar -->
    <header class="header flex justify-between items-center fixed w-full top-0 z-50">
        <div class="flex items-center space-x-3">
            <!-- Clickable Logo -->
            <a href="#" id="homeLogo" class="flex items-center space-x-2 no-underline text-white hover:text-blue-400 transition duration-200">
                <span class="text-3xl font-bold text-blue-500">VividVerse</span>
                <span class="text-gray-400 text-base">Blog</span>
            </a>
        </div>
        <div class="flex items-center space-x-4">
            <button id="authTriggerBtn" class="button-primary hidden">Login / Sign Up</button>
            <div id="profileSection" class="relative hidden">
                <div id="profileInitialsBtn" class="profile-initials"></div>
                <div id="profileDropdown" class="dropdown-menu hidden">
                    <button id="logoutBtn">Logout</button>
                </div>
            </div>
        </div>
    </header>

    <div class="main-container mx-auto p-4 sm:p-6 lg:p-8 mt-20">
        <h1 class="text-4xl font-bold mb-8 text-center text-blue-400">Discover Vivid Perspectives</h1>

        <!-- Static Articles Section (Inspiration from Reddit's landing page) -->
        <section id="static-articles-section" class="mb-12">
            <h2 class="text-2xl font-semibold mb-6 text-gray-100">Popular Reads</h2>
            <div id="static-articles-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Static articles will be loaded here by JS -->
            </div>
        </section>

        <!-- Dynamic Posts Timeline Section -->
        <section id="posts-timeline-section" class="mb-8 card">
            <h2 class="text-2xl font-semibold mb-6 text-gray-100 text-center">Recent Posts</h2>
            <button id="createPostFab" class="button-primary mb-4 w-full md:w-auto hidden">Create New Post</button>
            <div id="posts-container" class="space-y-6">
                <!-- Dynamic posts will be loaded here -->
            </div>
            <div class="text-center mt-6">
                <button id="loadMorePostsBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-full hidden">Load More Posts</button>
            </div>
            <p id="postMessage" class="mt-4 text-sm text-center"></p>
        </section>

        <!-- Single Post View & Comments Section (Hidden by default) -->
        <section id="single-post-view" class="hidden">
            <!-- Back to Home Button -->
            <button id="backToTimelineBtn" class="bg-gray-700 hover:bg-gray-800 text-gray-200 font-bold py-2 px-4 rounded mb-4 flex items-center">
                <i class="fas fa-arrow-left mr-2"></i> Back to Home
            </button>
            <div id="full-post-content" class="card mb-6">
                <h2 id="singlePostTitle" class="text-3xl font-bold mb-2 text-gray-100"></h2>
                <p class="text-sm text-gray-400 mb-4">By <span id="singlePostAuthor"></span> on <span id="singlePostDate"></span></p>
                <p id="singlePostText" class="text-gray-300 leading-relaxed"></p>
                <div class="mt-4 flex space-x-2">
                     <button id="editPostBtn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-1 px-3 rounded text-sm hidden">Edit</button>
                     <button id="deletePostBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded text-sm hidden">Delete</button>
                </div>
            </div>

            <!-- Comments Display -->
            <div id="comments-container" class="space-y-4 mb-6"> <!-- Added mb-6 here -->
                <h3 class="text-2xl font-semibold mb-4 text-gray-100">Comments</h3>
                <!-- Comments will be loaded here -->
            </div>

            <!-- Comment Submission -->
            <div id="comment-submission-section" class="card mb-6">
                <h3 class="text-xl font-semibold mb-3 text-gray-100">Add a Comment</h3>
                <textarea id="commentContent" placeholder="Write your comment..." class="input-field h-24 mb-3"></textarea>
                <button id="addCommentBtn" class="button-primary w-full">Add Comment</button>
                <p id="commentMessage" class="mt-2 text-sm text-center"></p>
            </div>
        </section>
    </div>

    <!-- Authentication Modal -->
    <div id="authModal" class="fixed inset-0 flex items-center justify-center z-50 hidden">
        <div class="modal-overlay absolute inset-0"></div>
        <div class="modal-content relative p-6">
            <button id="closeModalBtn" class="absolute top-3 right-3 text-gray-400 hover:text-gray-100 text-2xl font-bold">&times;</button>
            <div class="flex border-b border-gray-700 mb-6">
                <button id="loginTabBtn" class="tab-button active">Login</button>
                <button id="signupTabBtn" class="tab-button">Sign Up</button>
            </div>

            <!-- Login Form -->
            <div id="loginForm" class="auth-form-tab">
                <h2 class="text-2xl font-bold mb-6 text-center text-gray-100">Login to VividVerse</h2>
                <input type="text" id="modalUsernameLogin" placeholder="Username" class="input-field mb-4">
                <input type="password" id="modalPasswordLogin" placeholder="Password" class="input-field mb-6">
                <button id="modalLoginBtn" class="button-primary w-full">Login</button>
                <p id="modalAuthMessage" class="mt-4 text-sm text-center"></p>
            </div>

            <!-- Sign Up Form -->
            <div id="signupForm" class="auth-form-tab hidden">
                <h2 class="text-2xl font-bold mb-6 text-center text-gray-100">Join VividVerse</h2>
                <input type="text" id="modalUsernameSignup" placeholder="Username" class="input-field mb-4">
                <input type="password" id="modalPasswordSignup" placeholder="Password" class="input-field mb-4">
                <input type="text" id="modalDisplayNameSignup" placeholder="Display Name" class="input-field mb-4">
                <input type="email" id="modalEmailSignup" placeholder="Email" class="input-field mb-6">
                <button id="modalSignupBtn" class="button-primary w-full">Sign Up</button>
                <p id="modalAuthMessageSignup" class="mt-4 text-sm text-center"></p>
            </div>
        </div>
    </div>

    <script>
        const API_GATEWAY_URL = 'http://localhost:8080'; // IMPORTANT: Change to your desktop's IP for mobile access! E.g., 'http://192.168.1.100:8080'
        let currentUserId = null;
        let currentUsername = null;
        let currentDisplayName = null;
        let currentPostPage = 0;
        const POSTS_PER_PAGE = 5; 

        // Cache for user display names (userId -> displayName)
        const userDisplayNameCache = new Map();

        // --- DOM Elements ---
        const homeLogo = document.getElementById('homeLogo'); // New: for clickable logo
        const authTriggerBtn = document.getElementById('authTriggerBtn');
        const profileSection = document.getElementById('profileSection');
        const profileInitialsBtn = document.getElementById('profileInitialsBtn');
        const profileDropdown = document.getElementById('profileDropdown');
        const logoutBtn = document.getElementById('logoutBtn');

        const createPostFab = document.getElementById('createPostFab');
        const postsContainer = document.getElementById('posts-container');
        const loadMorePostsBtn = document.getElementById('loadMorePostsBtn');
        const singlePostView = document.getElementById('single-post-view');
        const backToTimelineBtn = document.getElementById('backToTimelineBtn');
        let currentViewedPostId = null;

        const singlePostTitle = document.getElementById('singlePostTitle');
        const singlePostAuthor = document.getElementById('singlePostAuthor');
        const singlePostDate = document.getElementById('singlePostDate');
        const singlePostText = document.getElementById('singlePostText');
        const editPostBtn = document.getElementById('editPostBtn');
        const deletePostBtn = document.getElementById('deletePostBtn');

        const commentSubmissionSection = document.getElementById('comment-submission-section');
        const commentContentInput = document.getElementById('commentContent');
        const addCommentBtn = document.getElementById('addCommentBtn');
        const commentMessage = document.getElementById('commentMessage');
        const commentsContainer = document.getElementById('comments-container');

        // Modal elements
        const authModal = document.getElementById('authModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const loginTabBtn = document.getElementById('loginTabBtn');
        const signupTabBtn = document.getElementById('signupTabBtn');
        const loginForm = document.getElementById('loginForm');
        const signupForm = document.getElementById('signupForm');
        const modalUsernameLogin = document.getElementById('modalUsernameLogin');
        const modalPasswordLogin = document.getElementById('modalPasswordLogin');
        const modalLoginBtn = document.getElementById('modalLoginBtn');
        const modalAuthMessage = document.getElementById('modalAuthMessage');
        const modalUsernameSignup = document.getElementById('modalUsernameSignup');
        const modalPasswordSignup = document.getElementById('modalPasswordSignup');
        const modalDisplayNameSignup = document.getElementById('modalDisplayNameSignup');
        const modalEmailSignup = document.getElementById('modalEmailSignup');
        const modalSignupBtn = document.getElementById('modalSignupBtn');
        const modalAuthMessageSignup = document.getElementById('modalAuthMessageSignup');

        // Static Articles Data (authors now consistent for Reddit-like display)
        const staticArticles = [
            {
                id: 'static-1',
                title: 'Exploring the Rich Tapestry of Indian Classical Dance',
                content: 'From the intricate footwork of Bharatanatyam to the graceful storytelling of Kathak, Indian classical dance forms are a vibrant part of the nation\'s cultural heritage. Each form tells a unique story, blending devotion, myth, and intricate rhythm.',
                imageUrl: 'https://placehold.co/600x350/b0e0e6/1a1a1a?text=Indian+Dance',
                subreddit: 'r/Culture',
                author: 'CultureExplorer', // Consistent username-like format
                date: '4 hr. ago',
                upvotes: 767, comments: 87, shares: 12
            },
            {
                id: 'static-2',
                title: 'The Rise of Regional Cinema: Beyond Bollywood',
                content: 'While Bollywood dominates the headlines, the last decade has seen an incredible surge in regional Indian cinema, with industries like Tollywood, Kollywood, and Mollywood producing critically acclaimed and commercially successful films that captivate audiences nationwide.',
                imageUrl: 'https://placehold.co/600x350/add8e6/1a1a1a?text=Regional+Cinema',
                subreddit: 'r/Movies',
                author: 'FilmBuff', // Consistent username-like format
                date: '2 days ago',
                upvotes: 1500, comments: 230, shares: 50
            },
            {
                id: 'static-3',
                title: 'IPL 2024: A Season of Unpredictable Thrills',
                content: 'The 2024 Indian Premier League was a rollercoaster of emotions, with underdog stories, record-breaking performances, and nail-biting finishes. This season truly exemplified the spirit of cricket, keeping fans on the edge of their seats until the very last ball.',
                imageUrl: 'https://placehold.co/600x350/87ceeb/1a1a1a?text=IPL+Highlights',
                subreddit: 'r/Cricket',
                author: 'CricketFan', // Consistent username-like format
                date: '1 week ago',
                upvotes: 2500, comments: 450, shares: 100
            }
        ];

        // --- Helper Functions ---
        function showMessage(element, message, isError = false) {
            element.textContent = message;
            element.className = `mt-4 text-sm text-center ${isError ? 'text-red-400' : 'text-green-400'}`;
        }

        function clearMessage(element) {
            element.textContent = '';
            element.className = '';
        }

        function isAuthenticated() {
            return currentUserId !== null;
        }

        function updateUIAfterAuth() {
            if (isAuthenticated()) {
                authTriggerBtn.classList.add('hidden');
                profileSection.classList.remove('hidden');
                profileInitialsBtn.textContent = getInitials(currentDisplayName || currentUsername);
                
                createPostFab.classList.remove('hidden');
                commentSubmissionSection.classList.remove('hidden');
            } else {
                authTriggerBtn.classList.remove('hidden');
                profileSection.classList.add('hidden');
                createPostFab.classList.add('hidden');
                commentSubmissionSection.classList.add('hidden');
            }
            if (singlePostView.classList.contains('active') && currentViewedPostId) {
                viewSinglePost(currentViewedPostId); 
            }
        }

        function getInitials(name) {
            if (!name) return '';
            const parts = name.split(' ');
            if (parts.length === 1) {
                return parts[0].charAt(0).toUpperCase();
            }
            return (parts[0].charAt(0) + parts[parts.length - 1].charAt(0)).toUpperCase();
        }

        async function fetchWithAuth(url, options = {}) {
            const response = await fetch(url, options);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText || `HTTP error! status: ${response.status}`);
            }
            return response.json();
        }

        function formatDateTime(isoString) {
            if (!isoString) return '';
            const date = new Date(isoString);
            return date.toLocaleString('en-IN', {
                year: 'numeric', month: 'long', day: 'numeric',
                hour: '2-digit', minute: '2-digit'
            });
        }

        /**
         * Fetches user display name from cache or API and updates cache.
         * @param {string} userId - The UUID of the user.
         * @returns {Promise<string>} - The display name or "Unknown User".
         */
        async function fetchUserDisplayName(userId) {
            if (userDisplayNameCache.has(userId)) {
                return userDisplayNameCache.get(userId);
            }
            try {
                const userProfile = await fetchWithAuth(`${API_GATEWAY_URL}/users/${userId}`);
                userDisplayNameCache.set(userId, userProfile.displayName);
                return userProfile.displayName;
            } catch (error) {
                console.error(`Failed to fetch display name for user ${userId}:`, error);
                userDisplayNameCache.set(userId, "Unknown User"); // Cache "Unknown User" to avoid repeated failed requests
                return "Unknown User";
            }
        }


        // --- Authentication Modal Logic ---
        authTriggerBtn.addEventListener('click', () => {
            authModal.classList.remove('hidden');
            switchAuthTab('login');
        });

        closeModalBtn.addEventListener('click', () => {
            authModal.classList.add('hidden');
            clearAuthModalForms();
        });

        loginTabBtn.addEventListener('click', () => switchAuthTab('login'));
        signupTabBtn.addEventListener('click', () => switchAuthTab('signup'));

        function switchAuthTab(tab) {
            loginTabBtn.classList.remove('active');
            signupTabBtn.classList.remove('active');
            loginForm.classList.add('hidden');
            signupForm.classList.add('hidden');
            clearMessage(modalAuthMessage);
            clearMessage(modalAuthMessageSignup);

            if (tab === 'login') {
                loginTabBtn.classList.add('active');
                loginForm.classList.remove('hidden');
            } else {
                signupTabBtn.classList.add('active');
                signupForm.classList.remove('hidden');
            }
        }

        function clearAuthModalForms() {
            modalUsernameLogin.value = '';
            modalPasswordLogin.value = '';
            modalUsernameSignup.value = '';
            modalPasswordSignup.value = '';
            modalDisplayNameSignup.value = '';
            modalEmailSignup.value = '';
            clearMessage(modalAuthMessage);
            clearMessage(modalAuthMessageSignup);
        }

        modalSignupBtn.addEventListener('click', async () => {
            clearMessage(modalAuthMessageSignup);
            const username = modalUsernameSignup.value;
            const password = modalPasswordSignup.value;
            const displayName = modalDisplayNameSignup.value;
            const email = modalEmailSignup.value;

            try {
                const newUser = await fetchWithAuth(`${API_GATEWAY_URL}/users/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password, email, displayName })
                });
                showMessage(modalAuthMessageSignup, `User ${newUser.username} registered successfully! You can now login.`);
                // Add new user to cache upon successful registration
                userDisplayNameCache.set(newUser.id, newUser.displayName);
                clearAuthModalForms();
                switchAuthTab('login');
            } catch (error) {
                showMessage(modalAuthMessageSignup, `Signup failed: ${error.message}`, true);
            }
        });

        modalLoginBtn.addEventListener('click', async () => {
            clearMessage(modalAuthMessage);
            const username = modalUsernameLogin.value;
            const password = modalPasswordLogin.value;

            try {
                const userProfile = await fetchWithAuth(`${API_GATEWAY_URL}/users/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                currentUserId = userProfile.id;
                currentUsername = userProfile.username;
                currentDisplayName = userProfile.displayName;
                // Add logged-in user to cache
                userDisplayNameCache.set(userProfile.id, userProfile.displayName);
                showMessage(modalAuthMessage, `Welcome, ${userProfile.displayName}!`, false);
                authModal.classList.add('hidden');
                clearAuthModalForms();
                updateUIAfterAuth();
                loadRecentPosts(true);
            } catch (error) {
                currentUserId = null;
                currentUsername = null;
                currentDisplayName = null;
                showMessage(modalAuthMessage, `Login failed: ${error.message}`, true);
                updateUIAfterAuth();
            }
        });

        // --- Profile Dropdown / Logout ---
        profileInitialsBtn.addEventListener('click', (e) => {
            profileDropdown.classList.toggle('hidden');
            e.stopPropagation();
        });

        logoutBtn.addEventListener('click', () => {
            currentUserId = null;
            currentUsername = null;
            currentDisplayName = null;
            profileDropdown.classList.add('hidden');
            updateUIAfterAuth();
            loadRecentPosts(true);
            // Instead of alert, use a custom message box if needed.
            // For now, reload to ensure UI reflects logout and clears data.
            window.location.reload(); 
        });

        window.addEventListener('click', (e) => {
            if (!profileSection.contains(e.target) && !profileDropdown.classList.contains('hidden')) {
                profileDropdown.classList.add('hidden');
            }
        });

        // --- Static Articles Renderer (Updated for Reddit-like post structure) ---
        function renderStaticArticles() {
            const container = document.getElementById('static-articles-container');
            container.innerHTML = '';
            staticArticles.forEach(article => {
                const articleCard = document.createElement('div');
                articleCard.className = 'card overflow-hidden';
                articleCard.innerHTML = `
                    <div class="p-4">
                        <div class="reddit-post-header">
                            <span class="subreddit-icon">R/</span>
                            <span class="font-semibold text-gray-300">${article.subreddit}</span>
                            <span class="mx-1 text-gray-500">•</span>
                            <span class="text-gray-500">Posted by u/${article.author} ${article.date}</span>
                        </div>
                        <h3 class="text-xl font-bold mb-2 text-gray-100">${article.title}</h3>
                        <p class="text-gray-300 text-sm mb-3">${article.content}</p>
                        <img src="${article.imageUrl}" alt="${article.title}" class="w-full h-auto object-cover rounded-lg mb-4">
                        <div class="reddit-post-footer">
                            <button class="flex items-center text-gray-400 hover:text-blue-400">
                                <i class="fas fa-arrow-up"></i>
                                <span class="count">${article.upvotes}</span>
                                <i class="fas fa-arrow-down ml-2"></i>
                            </button>
                            <button class="flex items-center text-gray-400 hover:text-blue-400 ml-4">
                                <i class="far fa-comment-alt"></i>
                                <span class="count">${article.comments} Comments</span>
                            </button>
                            <button class="flex items-center text-gray-400 hover:text-blue-400 ml-4">
                                <i class="fas fa-share"></i>
                                <span>Share</span>
                            </button>
                        </div>
                    </div>
                `;
                container.appendChild(articleCard);
            });
        }

        // --- Post Handlers (Updated for Reddit-like post structure) ---
        createPostFab.addEventListener('click', () => {
            if (!isAuthenticated()) {
                alert("Please login to create a post.");
                return;
            }
            const existingForm = document.getElementById('inline-create-post-form');
            if (existingForm) {
                existingForm.remove(); // Remove if already exists
                createPostFab.classList.remove('hidden'); // Show FAB again
                return;
            }

            const postFormSection = document.createElement('div');
            postFormSection.id = 'inline-create-post-form';
            postFormSection.className = 'card mb-6';
            postFormSection.innerHTML = `
                <h2 class="text-2xl font-semibold mb-4 text-gray-100">Post</h2> <!-- Changed title to "Post" -->
                <input type="text" id="inlinePostTitle" placeholder="Post Title" class="input-field mb-3">
                <textarea id="inlinePostContent" placeholder="Post Content" class="input-field h-32 mb-3"></textarea>
                <button id="inlineCreatePostBtn" class="button-primary w-full">Create Post</button>
                <p id="inlinePostMessage" class="mt-2 text-sm text-center"></p>
            `;
            postsContainer.before(postFormSection);
            createPostFab.classList.add('hidden');

            const inlinePostTitleInput = document.getElementById('inlinePostTitle');
            const inlinePostContentInput = document.getElementById('inlinePostContent');
            const inlineCreatePostBtn = document.getElementById('inlineCreatePostBtn');
            const inlinePostMessage = document.getElementById('inlinePostMessage');

            inlineCreatePostBtn.addEventListener('click', async () => {
                clearMessage(inlinePostMessage);
                const title = inlinePostTitleInput.value;
                const content = inlinePostContentInput.value;

                try {
                    const newPost = await fetchWithAuth(`${API_GATEWAY_URL}/posts`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ title, content, userId: currentUserId })
                    });
                    showMessage(inlinePostMessage, "Post created successfully!", false);
                    inlinePostTitleInput.value = '';
                    inlinePostContentInput.value = '';
                    loadRecentPosts(true);
                    postFormSection.remove();
                    createPostFab.classList.remove('hidden');
                } catch (error) {
                    showMessage(inlinePostMessage, `Failed to create post: ${error.message}`, true);
                }
            });
            window.scrollTo({ top: postFormSection.offsetTop - 80, behavior: 'smooth' });
        });


        loadMorePostsBtn.addEventListener('click', () => {
            currentPostPage++;
            loadRecentPosts(false);
        });

        async function loadRecentPosts(clearExisting = false) {
            if (clearExisting) {
                postsContainer.innerHTML = '';
                currentPostPage = 0;
            }

            try {
                const response = await fetchWithAuth(`${API_GATEWAY_URL}/posts?page=${currentPostPage}&size=${POSTS_PER_PAGE}`);
                const posts = response.content; 

                if (posts.length > 0) {
                    // Fetch display names for all unique user IDs in current batch of posts
                    const userIds = [...new Set(posts.map(post => post.userId))];
                    await Promise.all(userIds.map(id => fetchUserDisplayName(id))); // Populate cache

                    for (const post of posts) {
                        const authorDisplayName = userDisplayNameCache.get(post.userId) || "Unknown User";
                        const postCard = document.createElement('div');
                        postCard.className = 'card p-4 mb-4';
                        postCard.innerHTML = `
                            <div class="p-4">
                                <div class="reddit-post-header">
                                    <span class="subreddit-icon">U/</span>
                                    <span class="font-semibold text-gray-300">${authorDisplayName}</span> 
                                    <span class="mx-1 text-gray-500">•</span>
                                    <span class="text-gray-500">Posted by u/${authorDisplayName} ${formatDateTime(post.createdAt)}</span>
                                </div>
                                <h3 class="text-xl font-bold text-gray-100 mb-2">${post.title}</h3>
                                <p class="text-gray-300 text-sm mb-3">${post.content.substring(0, 150)}...</p>
                                <!-- No image for dynamic posts yet, but can be added later -->
                                <div class="reddit-post-footer">
                                    <button class="flex items-center text-gray-400 hover:text-blue-400">
                                        <i class="fas fa-arrow-up"></i>
                                        <span class="count">Vote</span>
                                        <i class="fas fa-arrow-down ml-2"></i>
                                    </button>
                                    <button data-post-id="${post.id}" class="view-post-btn flex items-center text-gray-400 hover:text-blue-400 ml-4">
                                        <i class="far fa-comment-alt"></i>
                                        <span>Comments</span>
                                    </button>
                                    <button class="flex items-center text-gray-400 hover:text-blue-400 ml-4">
                                        <i class="fas fa-share"></i>
                                        <span>Share</span>
                                    </button>
                                </div>
                            </div>
                        `;
                        postsContainer.appendChild(postCard);
                    }
                    loadMorePostsBtn.classList.remove('hidden');
                    if (response.last) { 
                        loadMorePostsBtn.classList.add('hidden');
                    }
                } else {
                    if (currentPostPage === 0) {
                        postsContainer.innerHTML = '<p class="text-center text-gray-500">No posts available. Be the first to create one!</p>';
                    }
                    loadMorePostsBtn.classList.add('hidden');
                }
            } catch (error) {
                postsContainer.innerHTML = `<p class="text-center text-red-400">Failed to load posts: ${error.message}</p>`;
                loadMorePostsBtn.classList.add('hidden');
            }
        }

        postsContainer.addEventListener('click', (e) => {
            if (e.target.closest('.view-post-btn') && e.target.closest('.view-post-btn').dataset.postId) {
                const postId = e.target.closest('.view-post-btn').dataset.postId;
                viewSinglePost(postId);
            }
        });

        backToTimelineBtn.addEventListener('click', () => {
            singlePostView.classList.add('hidden');
            document.getElementById('posts-timeline-section').classList.remove('hidden');
            renderStaticArticles(); 
            loadRecentPosts(true); 
        });

        async function viewSinglePost(postId) {
            try {
                const post = await fetchWithAuth(`${API_GATEWAY_URL}/posts/${postId}`);
                const authorDisplayName = await fetchUserDisplayName(post.userId); // Fetch author's display name

                singlePostTitle.textContent = post.title;
                singlePostAuthor.textContent = authorDisplayName; 
                singlePostDate.textContent = formatDateTime(post.createdAt);
                singlePostText.textContent = post.content;

                currentViewedPostId = postId;

                editPostBtn.classList.add('hidden');
                deletePostBtn.classList.add('hidden');
                if (isAuthenticated() && post.userId === currentUserId) {
                     editPostBtn.classList.remove('hidden');
                     deletePostBtn.classList.remove('hidden');
                }

                loadCommentsForPost(postId);

                document.getElementById('posts-timeline-section').classList.add('hidden');
                singlePostView.classList.remove('hidden');
            } catch (error) {
                alert(`Error loading post: ${error.message}`);
            }
        }

        editPostBtn.addEventListener('click', () => {
            if (!currentViewedPostId) return;
            const newTitle = prompt("Edit Title:", singlePostTitle.textContent);
            const newContent = prompt("Edit Content:", singlePostText.textContent);

            if (newTitle !== null && newContent !== null) {
                updatePost(currentViewedPostId, newTitle, newContent);
            }
        });

        async function updatePost(postId, title, content) {
             try {
                await fetchWithAuth(`${API_GATEWAY_URL}/posts/${postId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, content })
                });
                alert("Post updated successfully!");
                viewSinglePost(postId); 
            } catch (error) {
                alert(`Failed to update post: ${error.message}`);
            }
        } 

        deletePostBtn.addEventListener('click', async () => {
            if (!currentViewedPostId) return;
            // Using a custom message box instead of alert/confirm
            showCustomConfirmation("Are you sure you want to delete this post?", async () => {
                try {
                    await fetch(`${API_GATEWAY_URL}/posts/${currentViewedPostId}`, { method: 'DELETE' });
                    alert("Post deleted successfully!"); // Still using alert for final confirmation
                    backToTimelineBtn.click();
                } catch (error) {
                    alert(`Failed to delete post: ${error.message}`);
                }
            });
        });

        // Custom Confirmation Modal (replacing window.confirm)
        function showCustomConfirmation(message, onConfirm) {
            const modalHtml = `
                <div id="customConfirmModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[9999]">
                    <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-white text-center max-w-sm">
                        <p class="text-lg font-semibold mb-6">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYesBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-5 rounded-md transition duration-200">Yes</button>
                            <button id="confirmNoBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-5 rounded-md transition duration-200">No</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            document.getElementById('confirmYesBtn').addEventListener('click', () => {
                document.getElementById('customConfirmModal').remove();
                if (onConfirm) onConfirm();
            });

            document.getElementById('confirmNoBtn').addEventListener('click', () => {
                document.getElementById('customConfirmModal').remove();
            });
        }


        // --- Comment Handlers ---
        addCommentBtn.addEventListener('click', async () => {
            clearMessage(commentMessage);
            if (!isAuthenticated()) {
                showMessage(commentMessage, "Please login to add a comment.", true);
                return;
            }
            if (!currentViewedPostId) {
                showMessage(commentMessage, "No post selected to comment on.", true);
                return;
            }
            const content = commentContentInput.value;

            try {
                const newComment = await fetchWithAuth(`${API_GATEWAY_URL}/comments`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ postId: currentViewedPostId, userId: currentUserId, content: content })
                });
                showMessage(commentMessage, "Comment added successfully!", false);
                commentContentInput.value = '';
                loadCommentsForPost(currentViewedPostId); 
            } catch (error) {
                showMessage(commentMessage, `Failed to add comment: ${error.message}`, true);
            }
        });

        async function loadCommentsForPost(postId) {
            commentsContainer.innerHTML = '<h3 class="text-2xl font-semibold mb-4 text-gray-100">Comments</h3>'; 
            try {
                const comments = await fetchWithAuth(`${API_GATEWAY_URL}/comments/post/${postId}`);

                if (comments.length === 0) {
                    commentsContainer.innerHTML += '<p class="text-center text-gray-500 mt-4">No comments yet. Be the first to comment!</p>';
                }

                // Fetch display names for all unique user IDs in current batch of comments
                const userIds = [...new Set(comments.map(comment => comment.userId))];
                await Promise.all(userIds.map(id => fetchUserDisplayName(id))); // Populate cache

                const commentMap = new Map();
                comments.forEach(c => commentMap.set(c.id, { ...c, replies: [] }));

                const rootComments = [];
                comments.forEach(comment => {
                    if (comment.parentCommentId && commentMap.has(comment.parentCommentId)) {
                        commentMap.get(comment.parentCommentId).replies.push(commentMap.get(comment.id));
                    } else {
                        rootComments.push(commentMap.get(comment.id));
                    }
                });

                rootComments.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
                rootComments.forEach(comment => {
                    comment.replies.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
                });


                async function renderComment(comment, level = 0) { // Made async to await display name
                    const authorDisplayName = userDisplayNameCache.get(comment.userId) || "Unknown User";

                    const maxLevel = 3; 
                    const currentPadding = Math.min(level, maxLevel) * 8; // Tailwind ml- classes are multiples of 4 (e.g., ml-8 is 2rem)
                    const cardClass = level === 0 ? 'bg-gray-700' : (level === 1 ? 'bg-gray-800' : 'bg-gray-900'); 
                    
                    const commentDiv = document.createElement('div');
                    // Add nested-comment-border class if level > 0
                    commentDiv.className = `${cardClass} p-3 rounded-lg mb-2 ml-${currentPadding} ${level > 0 ? 'nested-comment-border' : ''}`; 
                    commentDiv.innerHTML = `
                        <p class="text-sm font-semibold text-gray-300"><span class="font-bold">${authorDisplayName}</span> <span class="text-xs text-gray-400 ml-2">${formatDateTime(comment.createdAt)}</span></p>
                        <p class="text-gray-200 mt-1">${comment.content}</p>
                        ${isAuthenticated() ? `<button data-comment-id="${comment.id}" class="reply-btn text-blue-400 hover:underline text-xs mt-2">Reply</button>` : ''}
                    `;
                    commentsContainer.appendChild(commentDiv);

                    if (isAuthenticated()) {
                        commentDiv.querySelector('.reply-btn')?.addEventListener('click', () => {
                            // Only allow one reply box at a time
                            const existingReplyBox = commentDiv.querySelector('.reply-box');
                            if (existingReplyBox) {
                                existingReplyBox.remove();
                                return;
                            }
                            addReplyBox(commentDiv, comment.id, postId);
                        });
                    }

                    // Await replies to ensure their display names are also fetched and rendered
                    for (const reply of comment.replies) {
                        await renderComment(reply, level + 1);
                    }
                }

                // Render comments sequentially to ensure display names are fetched
                for (const comment of rootComments) {
                    await renderComment(comment, 0);
                }

            } catch (error) {
                commentsContainer.innerHTML += `<p class="text-center text-red-400 mt-4">Failed to load comments: ${error.message}</p>`;
            }
        }

        function addReplyBox(targetElement, parentCommentId, postId) {
            // Remove any existing reply box to ensure only one is open at a time
            document.querySelectorAll('.reply-box').forEach(box => box.remove());

            const replyBoxHtml = `
                <div class="reply-box mt-3">
                    <textarea placeholder="Write your reply..." class="input-field w-full h-20 mb-2"></textarea>
                    <div class="flex justify-end space-x-2 button-group">
                        <button class="cancel-btn">Cancel</button>
                        <button class="comment-btn">Comment</button>
                    </div>
                    <p class="reply-message mt-2 text-sm text-center"></p>
                </div>
            `;
            targetElement.insertAdjacentHTML('beforeend', replyBoxHtml);

            const replyBox = targetElement.querySelector('.reply-box');
            const replyTextArea = replyBox.querySelector('textarea');
            const cancelBtn = replyBox.querySelector('.cancel-btn');
            const commentBtn = replyBox.querySelector('.comment-btn');
            const replyMessageElem = replyBox.querySelector('.reply-message');

            cancelBtn.addEventListener('click', () => {
                replyBox.remove();
            });

            commentBtn.addEventListener('click', async () => {
                const replyContent = replyTextArea.value;
                if (replyContent.trim() === "") {
                    showMessage(replyMessageElem, "Reply cannot be empty.", true);
                    return;
                }
                clearMessage(replyMessageElem);

                try {
                    await fetchWithAuth(`${API_GATEWAY_URL}/comments`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            postId: postId,
                            userId: currentUserId,
                            parentCommentId: parentCommentId,
                            content: replyContent
                        })
                    });
                    showMessage(replyMessageElem, "Reply added successfully!", false);
                    replyBox.remove(); // Remove the reply box after successful submission
                    loadCommentsForPost(postId); // Reload comments to show the new reply
                } catch (error) {
                    showMessage(replyMessageElem, `Failed to add reply: ${error.message}`, true);
                }
            });

            replyTextArea.focus(); // Focus on the new textarea
        }


        // Initial load calls
        document.addEventListener('DOMContentLoaded', () => {
            updateUIAfterAuth(); 
            renderStaticArticles(); 
            loadRecentPosts(true); 
        });

        // Clickable logo
        homeLogo.addEventListener('click', (e) => {
            e.preventDefault(); // Prevent default link behavior (full refresh)
            singlePostView.classList.add('hidden'); // Hide single post view
            document.getElementById('posts-timeline-section').classList.remove('hidden'); // Show timeline
            renderStaticArticles(); // Re-render static articles
            loadRecentPosts(true); // Re-load dynamic posts (clears existing)
            // No explicit logout here; user state is preserved
        });

    </script>
</body>
</html>
